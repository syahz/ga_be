// ge/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum ProcurementStatus {
  DRAFT
  PENDING_REVIEW
  PENDING_APPROVAL
  NEEDS_REVISION
  APPROVED
  REJECTED
}

enum LogAction {
  CREATED
  SUBMITTED
  REVIEWED
  APPROVED
  REJECTED
  REVISION_REQUESTED
  COMMENTED
}

enum StepType {
  CREATE
  REVIEW
  APPROVE
}


model ProcurementRule {
  id        String   @id @default(uuid())
  name      String   @unique
  minAmount BigInt   @map("min_amount")
  maxAmount BigInt?  @map("max_amount")
  
  // Relasi: Satu aturan memiliki banyak langkah
  steps     ProcurementStep[]

  @@map("procurement_rules")
}

model ProcurementStep {
  id      String   @id @default(uuid())
  ruleId  String
  roleId  String
  
  stepOrder Int      @map("step_order") // Urutan langkah: 1, 2, 3
  stepType  StepType @map("step_type")   // Tipe langkah: CREATE, REVIEW, atau APPROVE
  
  // Relasi: Setiap langkah terhubung ke satu aturan dan satu role
  rule    ProcurementRule @relation(fields: [ruleId], references: [id])
  role    Role            @relation(fields: [roleId], references: [id])

  @@map("procurement_steps")
}

// --- AKHIR DARI PERUBAHAN ---


model ProcurementLetter {
  id                  String   @id @default(uuid())
  unitId              String
  letterNumber        String   @unique @map("letter_number")
  letterAbout         String   @map("letter_about")
  nominal             BigInt
  incomingLetterDate  DateTime @map("incoming_letter_date")
  status              ProcurementStatus @default(DRAFT)
  letterFile          String  @map("letter_file")
  createdById         String
  currentApproverId   String?
  unit                Unit     @relation(fields: [unitId], references: [id])
  createdBy           User     @relation("CreatedBy", fields: [createdById], references: [id])
  currentApprover     User?    @relation("CurrentApprover", fields: [currentApproverId], references: [id])
  logs                ProcurementLog[]
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  @@map("procurement_letters")
}

model ProcurementLog {
  id                  String    @id @default(uuid())
  procurementLetterId String
  actorId             String
  action              LogAction
  comment             String?
  timestamp           DateTime  @default(now())
  procurementLetter   ProcurementLetter @relation(fields: [procurementLetterId], references: [id], onDelete: Cascade)
  actor               User              @relation(fields: [actorId], references: [id], onDelete: Cascade)

  @@map("procurement_logs")
}

model User {
  id                String   @id @default(uuid())
  name              String
  email             String   @unique
  password          String
  roleId            String
  unitId            String
  role              Role     @relation(fields: [roleId], references: [id])
  unit              Unit     @relation(fields: [unitId], references: [id])

  failedLogins  Int            @default(0)
  isLocked      Boolean        @default(false)
  
  createdLetters    ProcurementLetter[] @relation("CreatedBy")
  assignedLetters   ProcurementLetter[] @relation("CurrentApprover")
  refreshTokens     RefreshToken[]
  logs              ProcurementLog[]
}

model Role {
  id    String @id @default(uuid())
  name  String @unique
  users User[]
  // Relasi: Satu role bisa ada di banyak langkah persetujuan
  procurementSteps ProcurementStep[]
}

model Unit {
  id                 String   @id @default(uuid())
  code               String @unique
  name               String @unique
  users              User[]
  procurementLetters ProcurementLetter[]
}

// For Auth
model RefreshToken {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  tokenHash  String   @unique
  revoked    Boolean  @default(false)
  replacedBy String?
  createdAt  DateTime @default(now())
  expiresAt  DateTime

  @@map("refresh_tokens")
}